<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Advanced Playbook App</title>
  <!-- Bootstrap 5 CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <!-- Font Awesome for Icons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <!-- Chart.js for Analytics -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <!-- React and ReactDOM via CDN -->
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <!-- Babel for JSX -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    body {
      background-color: #f8f9fa;
    }
    .container {
      max-width: 1200px;
      margin-top: 80px;
      margin-bottom: 50px;
    }
    .card {
      margin-bottom: 20px;
    }
    .play-card {
      background-color: #ffffff;
      border: 1px solid #dee2e6;
      border-radius: 0.5rem;
      padding: 15px;
      margin-bottom: 10px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .navbar-brand {
      font-weight: bold;
    }
    .modal-backdrop.show {
      opacity: 0.5;
    }
    .cursor-pointer {
      cursor: pointer;
    }
    /* Responsive adjustments */
    @media (max-width: 768px) {
      .field-diagram {
        height: 150px;
      }
      .player-icon {
        width: 20px;
        height: 20px;
        font-size: 0.75rem;
      }
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <!-- Main Application Script -->
  <script type="text/babel">

    // Import necessary hooks and context from React
    const { useState, useEffect, useContext, createContext, useRef } = React;

    // Define player positions
    const playerPositions = ["QB", "RB", "WR", "TE", "OL", "DL", "LB", "CB", "S", "P", "K"];

    // Define play types with player positions
    const playTypes = {
      run: [
        { name: "Inside Zone", positions: ["RB", "OL"] },
        { name: "Outside Zone", positions: ["RB", "OL"] },
        { name: "Power", positions: ["RB", "OL"] },
        { name: "Counter", positions: ["RB", "OL"] },
        { name: "Draw", positions: ["RB", "OL"] },
        { name: "Sweep", positions: ["RB", "OL"] },
        { name: "Jet Sweep", positions: ["WR", "RB", "OL"] },
        { name: "Option Run", positions: ["QB", "RB", "OL"] },
        { name: "Counter Trey", positions: ["RB", "OL"] },
        { name: "Stretch", positions: ["RB", "OL"] },
        { name: "Draw Dive", positions: ["RB", "OL"] },
        { name: "Iso", positions: ["RB", "OL"] },
        { name: "Trap", positions: ["RB", "OL"] },
        { name: "Reverse", positions: ["WR", "RB"] },
        { name: "Draw Toss", positions: ["RB", "OL"] }
      ],
      pass: [
        { name: "Quick Pass", positions: ["QB", "WR", "TE"] },
        { name: "Play Action", positions: ["QB", "RB", "OL"] },
        { name: "Screen", positions: ["QB", "WR", "TE", "OL"] },
        { name: "Deep Pass", positions: ["QB", "WR", "TE", "CB", "S"] },
        { name: "RPO", positions: ["QB", "RB", "WR", "TE"] },
        { name: "Slant", positions: ["QB", "WR", "TE"] },
        { name: "Curl", positions: ["QB", "WR", "TE"] },
        { name: "Fade", positions: ["QB", "WR", "TE", "CB"] },
        { name: "Hitch", positions: ["QB", "WR", "TE"] },
        { name: "Vertical", positions: ["QB", "WR", "TE", "CB", "S"] },
        { name: "Bootleg", positions: ["QB", "WR", "TE"] },
        { name: "Tunnel", positions: ["QB", "WR", "TE"] },
        { name: "Shovel Pass", positions: ["QB", "RB", "WR", "TE"] },
        { name: "Bubble Screen", positions: ["QB", "WR", "TE"] },
        { name: "Corner Route", positions: ["QB", "WR", "TE", "CB"] }
      ],
      special: [
        { name: "Punt", positions: ["P"] },
        { name: "Field Goal", positions: ["K"] },
        { name: "Fake Punt", positions: ["P", "K", "QB", "RB"] },
        { name: "Fake Field Goal", positions: ["K", "QB", "RB"] },
        { name: "Onside Kick", positions: ["K"] },
        { name: "Punt Return", positions: ["RB", "CB", "S"] },
        { name: "Kickoff Return", positions: ["RB", "CB", "S"] },
        { name: "End Around", positions: ["WR", "RB"] },
        { name: "Reverse", positions: ["WR", "RB"] },
        { name: "Double Reverse", positions: ["WR", "RB"] },
        { name: "Spike", positions: ["QB"] },
        { name: "Quarterback Sneak", positions: ["QB", "OL"] },
        { name: "Halfback Pass", positions: ["RB", "QB"] },
        { name: "Option Pass", positions: ["QB", "RB"] },
        { name: "Hook and Ladder", positions: ["WR", "RB", "TE"] }
      ],
      custom: [] // Placeholder for custom plays
    };

    // Define formations
    const formations = [
      "I-Formation", "Shotgun", "Pistol", "Spread", "Singleback",
      "Wildcat", "Ace", "Empty", "Pro Set", "Trips",
      "Bunch", "Two Back", "Flexbone", "Diamond", "Wing-T", "Custom"
    ];

    // Define available categories
    const availableCategories = ["Offense", "Defense", "Special Teams", "Trick Plays"];

    // Initial Game Factors
    const initialGameFactors = {
      down: 1,
      distance: 10,
      fieldPosition: 50,
      timeRemaining: 1800, // in seconds
      score: { team: 0, opponent: 0 },
      quarter: 1,
      weather: "clear",
    };

    // Create Playbook Context for state management
    const PlaybookContext = createContext();

    const PlaybookProvider = ({ children }) => {
      const [playbook, setPlaybook] = useState([]);
      const [playHistory, setPlayHistory] = useState([]);

      useEffect(() => {
        // Load playbook from localStorage
        const storedPlaybook = JSON.parse(localStorage.getItem('playbook')) || [];
        setPlaybook(storedPlaybook);

        // Load play history from localStorage
        const storedPlayHistory = JSON.parse(localStorage.getItem('playHistory')) || [];
        setPlayHistory(storedPlayHistory);
      }, []);

      const addPlay = (play) => {
        const updatedPlaybook = [...playbook, play];
        setPlaybook(updatedPlaybook);
        localStorage.setItem('playbook', JSON.stringify(updatedPlaybook));
      };

      const deletePlay = (index) => {
        const updatedPlaybook = [...playbook];
        updatedPlaybook.splice(index, 1);
        setPlaybook(updatedPlaybook);
        localStorage.setItem('playbook', JSON.stringify(updatedPlaybook));
      };

      const addPlayHistory = (history) => {
        const updatedHistory = [...playHistory, history];
        setPlayHistory(updatedHistory);
        localStorage.setItem('playHistory', JSON.stringify(updatedHistory));
      };

      return (
        <PlaybookContext.Provider value={{ playbook, addPlay, deletePlay, playHistory, addPlayHistory }}>
          {children}
        </PlaybookContext.Provider>
      );
    };

    // Error Boundary Component
    class ErrorBoundary extends React.Component {
      constructor(props) {
        super(props);
        this.state = { hasError: false };
      }

      static getDerivedStateFromError(error) {
        return { hasError: true };
      }

      componentDidCatch(error, info) {
        console.error("ErrorBoundary caught an error", error, info);
      }

      render() {
        if (this.state.hasError) {
          return <div className="alert alert-danger">Something went wrong.</div>;
        }

        return this.props.children; 
      }
    }

    // Navbar Component
    const Navbar = () => (
      <nav className="navbar navbar-expand-lg navbar-dark bg-dark fixed-top">
        <div className="container-fluid">
          <a className="navbar-brand" href="#">Advanced Playbook</a>
        </div>
      </nav>
    );

    // Play Suggestion Component
    const PlaySuggestion = ({ onPlayRecorded }) => {
      const { playbook, playHistory, addPlayHistory } = useContext(PlaybookContext);
      const [gameFactors, setGameFactors] = useState(initialGameFactors);
      const [opponentData, setOpponentData] = useState({
        tendencies: { run: 0.6, pass: 0.4 },
        strengths: { defense: "balanced", offense: "balanced" },
      });
      const [suggestedPlay, setSuggestedPlay] = useState(null);
      const [recommendations, setRecommendations] = useState([]);
      const [loading, setLoading] = useState(false);
      const [feedback, setFeedback] = useState("");

      const aiSuggestPlay = () => {
        setLoading(true);
        setFeedback("");

        if (playbook.length === 0) {
          alert("Playbook is empty. Please add plays.");
          setLoading(false);
          return;
        }

        // Filter plays based on game factors and opponent data
        const filteredPlays = playbook.filter(play => {
          // Example conditions
          if (gameFactors.down >= 3 && play.type === "run") return false;
          if (gameFactors.distance > 15 && play.type !== "pass") return false;
          // Add more conditions as needed
          return true;
        });

        if (filteredPlays.length === 0) {
          alert("No suitable plays found for the current game situation.");
          setLoading(false);
          return;
        }

        // Sort plays based on success rates
        const sortedPlays = filteredPlays.sort((a, b) => {
          const aSuccess = a.successRate || 0.5;
          const bSuccess = b.successRate || 0.5;
          return bSuccess - aSuccess;
        });

        // Select the top play
        const topPlay = sortedPlays[0];
        setSuggestedPlay(topPlay);
        setLoading(false);
      };

      const generateRecommendations = () => {
        if (playbook.length === 0) {
          setRecommendations([]);
          return;
        }

        // Analyze current game situation and historical data to recommend plays
        const recommendationScores = playbook.map(play => {
          // Base score from success rate
          const successRate = play.successRate || 0.5;
          let score = successRate;

          // Adjust score based on game factors
          if (gameFactors.down >= 3 && play.type === "pass") score += 0.1;
          if (gameFactors.distance <= 5 && play.type === "run") score += 0.1;
          // Adjust based on opponent strengths
          if (opponentData.strengths.defense === "strong" && play.type === "pass") score += 0.05;
          if (opponentData.strengths.defense === "weak" && play.type === "run") score += 0.05;

          return { play, score };
        });

        // Sort recommendations by score
        const sortedRecommendations = recommendationScores.sort((a, b) => b.score - a.score).slice(0, 5).map(item => item.play);
        setRecommendations(sortedRecommendations);
      };

      useEffect(() => {
        generateRecommendations();
      }, [gameFactors, opponentData, playbook]);

      const handlePlayOutcome = (success) => {
        if (suggestedPlay) {
          // Update success rates
          const updatedPlaybook = playbook.map(play => {
            if (play.name === suggestedPlay.name) {
              const totalAttempts = play.totalAttempts || 0;
              const totalSuccesses = play.totalSuccesses || 0;
              const newTotalAttempts = totalAttempts + 1;
              const newTotalSuccesses = success ? totalSuccesses + 1 : totalSuccesses;
              return {
                ...play,
                totalAttempts: newTotalAttempts,
                totalSuccesses: newTotalSuccesses,
                successRate: newTotalAttempts > 0 ? (newTotalSuccesses / newTotalAttempts).toFixed(2) : 0.5
              };
            }
            return play;
          });

          // Update playbook in context and localStorage
          setPlaybook(updatedPlaybook);
          localStorage.setItem('playbook', JSON.stringify(updatedPlaybook));

          // Record play history
          const newHistory = {
            playName: suggestedPlay.name,
            playType: suggestedPlay.type,
            formation: suggestedPlay.formation,
            date: new Date().toISOString(),
            success
          };
          addPlayHistory(newHistory);

          setSuggestedPlay(null);
          setFeedback("Play outcome recorded!");
          setTimeout(() => setFeedback(""), 3000);

          // Notify parent component to refresh analytics
          if (onPlayRecorded) onPlayRecorded();
        }
      };

      const { setPlaybook } = useContext(PlaybookContext); // For updating playbook

      return (
        <div className="card">
          <div className="card-body">
            <h5 className="card-title">Play Suggestion</h5>
            <form>
              <div className="row mb-3">
                <div className="col-md-2 col-sm-4 col-6">
                  <label className="form-label">Down</label>
                  <input type="number" className="form-control" min="1" max="4"
                    value={gameFactors.down}
                    onChange={(e) => setGameFactors({ ...gameFactors, down: Number(e.target.value) })} />
                </div>
                <div className="col-md-2 col-sm-4 col-6">
                  <label className="form-label">Distance</label>
                  <input type="number" className="form-control" min="1" max="20"
                    value={gameFactors.distance}
                    onChange={(e) => setGameFactors({ ...gameFactors, distance: Number(e.target.value) })} />
                </div>
                <div className="col-md-2 col-sm-4 col-6">
                  <label className="form-label">Field Position (%)</label>
                  <input type="number" className="form-control" min="0" max="100"
                    value={gameFactors.fieldPosition}
                    onChange={(e) => setGameFactors({ ...gameFactors, fieldPosition: Number(e.target.value) })} />
                </div>
                <div className="col-md-3 col-sm-6 col-12">
                  <label className="form-label">Time Remaining (sec)</label>
                  <input type="number" className="form-control" min="0"
                    value={gameFactors.timeRemaining}
                    onChange={(e) => setGameFactors({ ...gameFactors, timeRemaining: Number(e.target.value) })} />
                </div>
                <div className="col-md-2 col-sm-6 col-12">
                  <label className="form-label">Quarter</label>
                  <input type="number" className="form-control" min="1" max="4"
                    value={gameFactors.quarter}
                    onChange={(e) => setGameFactors({ ...gameFactors, quarter: Number(e.target.value) })} />
                </div>
                <div className="col-md-1 col-sm-6 col-12">
                  <label className="form-label">Weather</label>
                  <select className="form-select"
                    value={gameFactors.weather}
                    onChange={(e) => setGameFactors({ ...gameFactors, weather: e.target.value })}>
                    <option value="clear">Clear</option>
                    <option value="rain">Rain</option>
                    <option value="snow">Snow</option>
                    <option value="windy">Windy</option>
                  </select>
                </div>
              </div>

              <hr />

              <h6>Opponent Data</h6>
              <div className="row mb-3">
                <div className="col-md-3 col-sm-6 col-12">
                  <label className="form-label">Run Tendency (0-1)</label>
                  <input type="number" className="form-control" min="0" max="1" step="0.1"
                    value={opponentData.tendencies.run}
                    onChange={(e) => setOpponentData({
                      ...opponentData,
                      tendencies: { ...opponentData.tendencies, run: Number(e.target.value) }
                    })} />
                </div>
                <div className="col-md-3 col-sm-6 col-12">
                  <label className="form-label">Pass Tendency (0-1)</label>
                  <input type="number" className="form-control" min="0" max="1" step="0.1"
                    value={opponentData.tendencies.pass}
                    onChange={(e) => setOpponentData({
                      ...opponentData,
                      tendencies: { ...opponentData.tendencies, pass: Number(e.target.value) }
                    })} />
                </div>
                <div className="col-md-3 col-sm-6 col-12">
                  <label className="form-label">Defense Strength</label>
                  <select className="form-select"
                    value={opponentData.strengths.defense}
                    onChange={(e) => setOpponentData({
                      ...opponentData,
                      strengths: { ...opponentData.strengths, defense: e.target.value }
                    })}>
                    <option value="strong">Strong</option>
                    <option value="balanced">Balanced</option>
                    <option value="weak">Weak</option>
                  </select>
                </div>
                <div className="col-md-3 col-sm-6 col-12">
                  <label className="form-label">Offense Strength</label>
                  <select className="form-select"
                    value={opponentData.strengths.offense}
                    onChange={(e) => setOpponentData({
                      ...opponentData,
                      strengths: { ...opponentData.strengths, offense: e.target.value }
                    })}>
                    <option value="strong">Strong</option>
                    <option value="balanced">Balanced</option>
                    <option value="weak">Weak</option>
                  </select>
                </div>
              </div>

              <button type="button" className="btn btn-primary" onClick={aiSuggestPlay} disabled={loading}>
                {loading ? "Suggesting Play..." : "Suggest Play"}
              </button>
            </form>

            {suggestedPlay && (
              <div className="mt-4 p-3 bg-light rounded">
                <h5>Suggested Play</h5>
                <p><strong>Type:</strong> {suggestedPlay.type.toUpperCase()}</p>
                <p><strong>Play:</strong> {suggestedPlay.name}</p>
                <p><strong>Formation:</strong> {suggestedPlay.formation}</p>
                {suggestedPlay.tags && suggestedPlay.tags.length > 0 && (
                  <p><strong>Tags:</strong> {suggestedPlay.tags.join(", ")}</p>
                )}
                <button className="btn btn-success me-2" onClick={() => handlePlayOutcome(true)}>
                  Success <i className="fas fa-check"></i>
                </button>
                <button className="btn btn-danger" onClick={() => handlePlayOutcome(false)}>
                  Failure <i className="fas fa-times"></i>
                </button>
              </div>
            )}

            {recommendations.length > 0 && (
              <div className="mt-4">
                <h5>Recommended Plays</h5>
                <ul className="list-group">
                  {recommendations.map((play, index) => (
                    <li key={index} className="list-group-item d-flex justify-content-between align-items-center">
                      {play.name} ({play.type.toUpperCase()})
                      <button className="btn btn-sm btn-secondary"
                        onClick={() => setSuggestedPlay(play)}>
                        Select <i className="fas fa-check"></i>
                      </button>
                    </li>
                  ))}
                </ul>
              </div>
            )}

            {feedback && <div className="alert alert-info mt-3">{feedback}</div>}
          </div>
        </div>
      );

    // Custom Play Form Component
    const CustomPlayForm = () => {
      const { addPlay } = useContext(PlaybookContext);
      const [name, setName] = useState("");
      const [type, setType] = useState("run");
      const [formation, setFormation] = useState("I-Formation");
      const [players, setPlayers] = useState("");
      const [categories, setCategories] = useState([]);
      const [tags, setTags] = useState("");
      const [error, setError] = useState("");
      const [success, setSuccess] = useState("");

      const handleSubmit = (e) => {
        e.preventDefault();
        setError("");
        setSuccess("");

        // Basic validation
        if (!name.trim()) {
          setError("Play name is required.");
          return;
        }
        if (!players.trim()) {
          setError("At least one player is required.");
          return;
        }
        if (categories.length === 0) {
          setError("At least one category must be selected.");
          return;
        }

        // Validate play type
        if (!playTypes[type] && type !== "custom") {
          setError("Invalid play type selected.");
          return;
        }

        const newPlay = {
          name: name.trim(),
          type,
          formation,
          players: players.split(",").map(p => p.trim()).filter(p => p !== ""),
          categories,
          tags: tags.split(",").map(t => t.trim()).filter(t => t !== "")
        };

        try {
          addPlay(newPlay);
          setName("");
          setType("run");
          setFormation("I-Formation");
          setPlayers("");
          setCategories([]);
          setTags("");
          setSuccess("Custom play added successfully!");
          setTimeout(() => setSuccess(""), 3000);
        } catch (err) {
          setError("Failed to add play. Please try again.");
        }
      };

      return (
        <div className="card">
          <div className="card-body">
            <h5 className="card-title">Create Custom Play</h5>
            {error && <div className="alert alert-danger">{error}</div>}
            {success && <div className="alert alert-success">{success}</div>}
            <form onSubmit={handleSubmit}>
              <div className="mb-3">
                <label className="form-label">Play Name</label>
                <input type="text" className="form-control" value={name}
                  onChange={(e) => setName(e.target.value)} required />
              </div>
              <div className="mb-3">
                <label className="form-label">Play Type</label>
                <select className="form-select" value={type}
                  onChange={(e) => setType(e.target.value)}>
                  {Object.keys(playTypes).map(pt => (
                    <option key={pt} value={pt}>{pt.toUpperCase()}</option>
                  ))}
                  <option value="custom">CUSTOM</option>
                </select>
              </div>
              <div className="mb-3">
                <label className="form-label">Formation</label>
                <select className="form-select" value={formation}
                  onChange={(e) => setFormation(e.target.value)}>
                  {formations.map(form => (
                    <option key={form} value={form}>{form}</option>
                  ))}
                </select>
              </div>
              <div className="mb-3">
                <label className="form-label">Players Involved (comma separated)</label>
                <input type="text" className="form-control" value={players}
                  onChange={(e) => setPlayers(e.target.value)} required />
              </div>
              <div className="mb-3">
                <label className="form-label">Categories</label>
                <select
                  className="form-select"
                  multiple
                  value={categories}
                  onChange={(e) => {
                    const selectedOptions = Array.from(e.target.selectedOptions).map(option => option.value);
                    setCategories(selectedOptions);
                  }}
                >
                  {availableCategories.map(cat => (
                    <option key={cat} value={cat}>{cat}</option>
                  ))}
                </select>
                <small className="form-text text-muted">Hold down the Ctrl (windows) or Command (Mac) button to select multiple options.</small>
              </div>
              <div className="mb-3">
                <label className="form-label">Tags (comma separated)</label>
                <input type="text" className="form-control" value={tags}
                  onChange={(e) => setTags(e.target.value)} />
              </div>
              <button type="submit" className="btn btn-primary">Add Custom Play</button>
            </form>
          </div>
        </div>
      );
    };

    // Playbook Display Component
    const Playbook = () => {
      const { playbook, deletePlay } = useContext(PlaybookContext);
      const [filterCategory, setFilterCategory] = useState("");
      const [filterTag, setFilterTag] = useState("");
      const [error, setError] = useState("");
      const [deleteFeedback, setDeleteFeedback] = useState("");

      const handleDelete = (index) => {
        if (confirm("Are you sure you want to delete this play?")) {
          deletePlay(index);
          setDeleteFeedback("Play deleted successfully!");
          setTimeout(() => setDeleteFeedback(""), 3000);
        }
      };

      const filteredPlays = playbook.filter(play => {
        const categoryMatch = filterCategory ? play.categories.includes(filterCategory) : true;
        const tagMatch = filterTag ? play.tags.some(tag => tag.toLowerCase().includes(filterTag.toLowerCase())) : true;
        return categoryMatch && tagMatch;
      });

      return (
        <div className="card">
          <div className="card-body">
            <h5 className="card-title">Your Playbook</h5>
            <div className="row mb-3">
              <div className="col-md-6 col-sm-12 mb-2">
                <label className="form-label">Filter by Category</label>
                <select className="form-select" value={filterCategory}
                  onChange={(e) => setFilterCategory(e.target.value)}>
                  <option value="">All</option>
                  {availableCategories.map(cat => (
                    <option key={cat} value={cat}>{cat}</option>
                  ))}
                </select>
              </div>
              <div className="col-md-6 col-sm-12 mb-2">
                <label className="form-label">Filter by Tag</label>
                <input
                  type="text"
                  className="form-control"
                  placeholder="Enter tag to filter"
                  value={filterTag}
                  onChange={(e) => setFilterTag(e.target.value)}
                />
              </div>
            </div>
            {error && <div className="alert alert-danger">{error}</div>}
            {deleteFeedback && <div className="alert alert-success">{deleteFeedback}</div>}
            {filteredPlays.length > 0 ? (
              filteredPlays.map((play, index) => (
                <div key={index} className="play-card">
                  <h6>{play.name}</h6>
                  <p><strong>Type:</strong> {play.type.toUpperCase()}</p>
                  <p><strong>Formation:</strong> {play.formation}</p>
                  <p><strong>Players:</strong> {play.players.join(", ")}</p>
                  {play.categories && play.categories.length > 0 && (
                    <p><strong>Categories:</strong> {play.categories.join(", ")}</p>
                  )}
                  {play.tags && play.tags.length > 0 && (
                    <p><strong>Tags:</strong> {play.tags.join(", ")}</p>
                  )}
                  <button className="btn btn-success btn-sm me-2"
                    onClick={() => alert(`Selected Play: ${play.name}\nFormation: ${play.formation}\nPlayers: ${play.players.join(", ")}`)}>
                    Select <i className="fas fa-check"></i>
                  </button>
                  <button className="btn btn-danger btn-sm"
                    onClick={() => handleDelete(index)}>
                    Delete <i className="fas fa-trash"></i>
                  </button>
                </div>
              ))
            ) : (
              <p>No plays match the filter criteria.</p>
            )}
          </div>
        </div>
      );
    };

    // Analytics Dashboard Component
    const Analytics = () => {
      const { playHistory } = useContext(PlaybookContext);
      const [loading, setLoading] = useState(true);
      const [error, setError] = useState("");
      const playTypeChartRef = useRef(null);
      const successTrendChartRef = useRef(null);
      const playFrequencyChartRef = useRef(null);
      const chartInstances = useRef({});

      const fetchPlayData = () => {
        setLoading(true);
        setError("");
        try {
          setLoading(false);
        } catch (err) {
          setError("Failed to load analytics.");
          setLoading(false);
        }
      };

      useEffect(() => {
        fetchPlayData();
      }, []);

      // Calculate play type distribution
      const playTypeCount = playHistory.reduce((acc, play) => {
        acc[play.playType] = (acc[play.playType] || 0) + 1;
        return acc;
      }, {});

      const playTypeChartData = {
        labels: Object.keys(playTypeCount).map(type => type.toUpperCase()),
        datasets: [{
          data: Object.values(playTypeCount),
          backgroundColor: [
            '#FF6384',
            '#36A2EB',
            '#FFCE56',
            '#4BC0C0',
            '#9966FF',
            '#FF9F40',
            '#FF9F40',
            '#36A2EB',
            '#FF6384'
          ],
        }]
      };

      // Calculate play success trend over time
      const playSuccessTrend = playHistory.map(play => ({
        date: new Date(play.date).toLocaleDateString(),
        success: play.success ? 1 : 0
      }));

      const groupedSuccessTrend = playSuccessTrend.reduce((acc, entry) => {
        if (!acc[entry.date]) acc[entry.date] = { successes: 0, attempts: 0 };
        acc[entry.date].attempts += 1;
        acc[entry.date].successes += entry.success;
        return acc;
      }, {});

      const successTrendChartData = {
        labels: Object.keys(groupedSuccessTrend),
        datasets: [{
          label: 'Success Rate',
          data: Object.keys(groupedSuccessTrend).map(date => {
            const { successes, attempts } = groupedSuccessTrend[date];
            return attempts > 0 ? (successes / attempts).toFixed(2) : 0;
          }),
          fill: false,
          borderColor: '#36A2EB',
          tension: 0.1
        }]
      };

      // Calculate play frequency
      const playFrequency = playHistory.reduce((acc, play) => {
        acc[play.playName] = (acc[play.playName] || 0) + 1;
        return acc;
      }, {});

      const playFrequencyChartData = {
        labels: Object.keys(playFrequency),
        datasets: [{
          label: 'Play Frequency',
          data: Object.values(playFrequency),
          backgroundColor: '#FF6384',
        }]
      };

      useEffect(() => {
        const ctx1 = playTypeChartRef.current.getContext('2d');
        const ctx2 = successTrendChartRef.current.getContext('2d');
        const ctx3 = playFrequencyChartRef.current.getContext('2d');

        // Destroy existing charts to prevent duplication
        Object.values(chartInstances.current).forEach(chart => chart.destroy());

        // Play Type Distribution Pie Chart
        chartInstances.current.playTypeChart = new Chart(ctx1, {
          type: 'pie',
          data: playTypeChartData,
          options: {
            responsive: true,
            plugins: {
              legend: { position: 'top' },
              title: { display: true, text: 'Play Type Distribution' }
            }
          },
        });

        // Success Rate Trend Line Chart
        chartInstances.current.successTrendChart = new Chart(ctx2, {
          type: 'line',
          data: successTrendChartData,
          options: {
            responsive: true,
            plugins: {
              legend: { position: 'top' },
              title: { display: true, text: 'Play Success Trend Over Time' }
            },
            scales: {
              y: {
                beginAtZero: true,
                max: 1
              }
            }
          },
        });

        // Play Frequency Bar Chart
        chartInstances.current.playFrequencyChart = new Chart(ctx3, {
          type: 'bar',
          data: playFrequencyChartData,
          options: {
            responsive: true,
            plugins: {
              legend: { display: false },
              title: { display: true, text: 'Play Frequency' }
            },
            scales: {
              y: { beginAtZero: true }
            }
          },
        });

        // Cleanup function to destroy charts on unmount
        return () => {
          Object.values(chartInstances.current).forEach(chart => chart.destroy());
        };
      }, [playTypeChartData, successTrendChartData, playFrequencyChartData]);

      return (
        <div className="card">
          <div className="card-body">
            <h5 className="card-title">Analytics Dashboard</h5>
            {loading ? (
              <p>Loading...</p>
            ) : error ? (
              <div className="alert alert-danger">{error}</div>
            ) : playHistory.length > 0 ? (
              <div>
                <canvas id="playTypeChart" ref={playTypeChartRef}></canvas>
                <canvas id="successTrendChart" ref={successTrendChartRef} className="mt-4"></canvas>
                <canvas id="playFrequencyChart" ref={playFrequencyChartRef} className="mt-4"></canvas>
              </div>
            ) : (
              <p>No data to display.</p>
            )}
          </div>
        </div>
      );
    };

    // Play Designer Component
    const PlayDesigner = ({ refreshPlaybook }) => {
      const { addPlay } = useContext(PlaybookContext);
      const [players, setPlayers] = useState([
        { id: 1, position: "QB", label: "QB" },
        { id: 2, position: "RB", label: "RB" },
        { id: 3, position: "WR", label: "WR" },
        { id: 4, position: "TE", label: "TE" },
        { id: 5, position: "OL", label: "OL" },
        { id: 6, position: "DL", label: "DL" },
        { id: 7, position: "LB", label: "LB" },
        { id: 8, position: "CB", label: "CB" },
        { id: 9, position: "S", label: "S" },
        { id: 10, position: "P", label: "P" },
        { id: 11, position: "K", label: "K" },
      ]);
      const [design, setDesign] = useState([]);
      const [error, setError] = useState("");
      const [success, setSuccess] = useState("");

      const handleDragStart = (e, player) => {
        e.dataTransfer.setData("playerId", player.id);
      };

      const handleDrop = (e, position) => {
        e.preventDefault();
        const playerId = e.dataTransfer.getData("playerId");
        const player = players.find(p => p.id === Number(playerId));
        if (player) {
          setDesign([...design, { ...player, x: position.x, y: position.y }]);
        }
      };

      const handleDragOver = (e) => {
        e.preventDefault();
      };

      const savePlayDesign = () => {
        if (design.length === 0) {
          setError("No players placed on the field.");
          return;
        }

        const playName = prompt("Enter Play Name:");
        if (!playName) {
          setError("Play name is required.");
          return;
        }

        const playType = prompt("Enter Play Type (run, pass, special):").toLowerCase();
        if (!playTypes[playType]) {
          setError("Invalid play type.");
          return;
        }

        const formation = prompt("Enter Formation:");
        if (!formation) {
          setError("Formation is required.");
          return;
        }

        const categoriesInput = prompt("Enter Categories (comma separated):");
        const categories = categoriesInput ? categoriesInput.split(",").map(c => c.trim()).filter(c => c !== "") : [];

        const tagsInput = prompt("Enter Tags (comma separated):");
        const tags = tagsInput ? tagsInput.split(",").map(t => t.trim()).filter(t => t !== "") : [];

        const newPlay = {
          name: playName,
          type: playType,
          formation,
          players: design.map(p => p.position),
          categories,
          tags
        };

        try {
          addPlay(newPlay);
          setDesign([]);
          setSuccess("Custom play saved successfully!");
          setTimeout(() => setSuccess(""), 3000);
          refreshPlaybook();
        } catch (err) {
          setError("Failed to save play. Please try again.");
        }
      };

      return (
        <div className="card">
          <div className="card-body">
            <h5 className="card-title">Drag-and-Drop Play Designer</h5>
            {error && <div className="alert alert-danger">{error}</div>}
            {success && <div className="alert alert-success">{success}</div>}
            <div className="d-flex">
              {/* Player Palette */}
              <div className="me-4">
                <h6>Players</h6>
                {players.map(player => (
                  <div
                    key={player.id}
                    draggable
                    onDragStart={(e) => handleDragStart(e, player)}
                    className="mb-2 p-2 bg-primary text-white rounded cursor-pointer"
                  >
                    {player.label}
                  </div>
                ))}
              </div>

              {/* Field Diagram */}
              <div
                className="field-diagram"
                style={{
                  position: "relative",
                  width: "600px",
                  height: "300px",
                  backgroundImage: "url('https://i.imgur.com/4AIuYyQ.png')", // Replace with field image URL
                  backgroundSize: "cover",
                  border: "2px solid #ccc",
                  borderRadius: "5px"
                }}
                onDrop={(e) => handleDrop(e, { x: e.clientX, y: e.clientY })}
                onDragOver={handleDragOver}
              >
                {design.map((player, index) => (
                  <div
                    key={index}
                    style={{
                      position: "absolute",
                      left: `${player.x * 0.1}%`,
                      top: `${player.y * 0.1}%`,
                      transform: "translate(-50%, -50%)",
                      width: "30px",
                      height: "30px",
                      borderRadius: "50%",
                      backgroundColor: "#28a745",
                      color: "#fff",
                      display: "flex",
                      alignItems: "center",
                      justifyContent: "center",
                      cursor: "pointer"
                    }}
                  >
                    {player.label}
                  </div>
                ))}
              </div>
            </div>
            <button className="btn btn-success mt-3" onClick={savePlayDesign} disabled={design.length === 0}>
              Save Custom Play
            </button>
          </div>
        </div>
      );
    };

    // Game Simulation Component
    const GameSimulator = () => {
      const { playbook } = useContext(PlaybookContext);
      const [simulations, setSimulations] = useState(1000);
      const [result, setResult] = useState(null);
      const [loading, setLoading] = useState(false);

      const runSimulation = () => {
        setLoading(true);
        setResult(null);

        try {
          if (playbook.length === 0) {
            alert("Playbook is empty. Please add plays to simulate.");
            setLoading(false);
            return;
          }

          let wins = 0;
          let totalScore = 0;

          for (let i = 0; i < simulations; i++) {
            let score = 0;
            // Simple simulation: iterate through plays and accumulate score
            playbook.forEach(play => {
              const successRate = play.successRate || 0.5; // Default success rate
              if (Math.random() < successRate) {
                // Assume a successful play adds points
                if (play.type === "run") score += 3;
                if (play.type === "pass") score += 4;
                if (play.type === "special") score += 2;
              }
            });
            totalScore += score;
            if (score > 50) wins += 1; // Arbitrary win condition
          }

          setResult({
            winRate: ((wins / simulations) * 100).toFixed(2),
            averageScore: (totalScore / simulations).toFixed(2)
          });
        } catch (err) {
          alert("An error occurred during simulation. Please try again.");
        } finally {
          setLoading(false);
        }
      };

      return (
        <div className="card">
          <div className="card-body">
            <h5 className="card-title">Game Simulation</h5>
            <div className="mb-3">
              <label className="form-label">Number of Simulations</label>
              <input
                type="number"
                className="form-control"
                value={simulations}
                onChange={(e) => setSimulations(Number(e.target.value))}
                min="100"
                max="10000"
              />
            </div>
            <button className="btn btn-primary" onClick={runSimulation} disabled={loading}>
              {loading ? "Simulating..." : "Run Simulation"}
            </button>

            {result && (
              <div className="mt-4">
                <h6>Simulation Results:</h6>
                <p><strong>Win Rate:</strong> {result.winRate}%</p>
                <p><strong>Average Score:</strong> {result.averageScore}</p>
              </div>
            )}
          </div>
        </div>
      );
    };

    // Play Recommendation System Component (Integrated within PlaySuggestion)
    // Already handled within PlaySuggestion's generateRecommendations and recommendations list

    // Error Handling and Data Validation are integrated within each component

    // Main App Component
    const App = () => {
      return (
        <ErrorBoundary>
          <PlaybookProvider>
            <Navbar />
            <div className="container">
              <div className="row">
                <div className="col-lg-6 col-md-12">
                  <PlaySuggestion />
                  <CustomPlayForm />
                  <PlayDesigner />
                  <GameSimulator />
                </div>
                <div className="col-lg-6 col-md-12">
                  <Playbook />
                  <Analytics />
                </div>
              </div>
            </div>
          </PlaybookProvider>
        </ErrorBoundary>
      );
    };

    // Render the App
    ReactDOM.createRoot(document.getElementById('root')).render(<App />);

  </script>

  <!-- Bootstrap 5 JS and dependencies -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
